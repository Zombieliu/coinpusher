/**
 * ğŸŒ Gateway Service
 *
 * æ— çŠ¶æ€ç½‘å…³æœåŠ¡
 * - æ¥æ”¶å®¢æˆ·ç«¯è¯·æ±‚
 * - è½¬å‘åˆ°ç‰©ç† Workerï¼ˆé€šè¿‡æ¶ˆæ¯é˜Ÿåˆ—ï¼‰
 * - è¿”å›å“åº”ç»™å®¢æˆ·ç«¯
 * - å¹¿æ’­ç‰©ç†å¸§æ›´æ–°
 */

import { MessageQueue, PhysicsRequest, PhysicsResponse, PhysicsFrame } from '../shared/MessageQueue';
import { DragonflyClientManager, SlidingWindowLimiter } from '../../tsrpc_server/src/server/utils/DragonflyRateLimiter';
import { EventEmitter } from 'events';
import { v4 as uuidv4 } from 'uuid';

/**
 * å¾…å¤„ç†çš„è¯·æ±‚
 */
interface PendingRequest {
    requestId: string;
    resolve: (data: any) => void;
    reject: (error: Error) => void;
    timeout: NodeJS.Timeout;
    timestamp: number;
}

/**
 * Gateway é…ç½®
 */
export interface GatewayConfig {
    gatewayId: string;
    port: number;
    dragonflyHost: string;
    dragonflyPort: number;
    requestTimeout: number;  // è¯·æ±‚è¶…æ—¶ï¼ˆæ¯«ç§’ï¼‰
}

/**
 * æˆ¿é—´è®¢é˜…ç®¡ç†
 */
class RoomSubscriptionManager extends EventEmitter {
    private subscriptions: Map<string, Set<string>> = new Map();  // roomId -> Set<connectionId>

    subscribe(roomId: string, connectionId: string): void {
        if (!this.subscriptions.has(roomId)) {
            this.subscriptions.set(roomId, new Set());
        }
        this.subscriptions.get(roomId)!.add(connectionId);
    }

    unsubscribe(roomId: string, connectionId: string): void {
        const subs = this.subscriptions.get(roomId);
        if (subs) {
            subs.delete(connectionId);
            if (subs.size === 0) {
                this.subscriptions.delete(roomId);
            }
        }
    }

    getSubscribers(roomId: string): Set<string> {
        return this.subscriptions.get(roomId) || new Set();
    }

    unsubscribeAll(connectionId: string): void {
        for (const [roomId, subs] of this.subscriptions.entries()) {
            subs.delete(connectionId);
            if (subs.size === 0) {
                this.subscriptions.delete(roomId);
            }
        }
    }

    getRoomCount(): number {
        return this.subscriptions.size;
    }

    getTotalSubscribers(): number {
        let count = 0;
        for (const subs of this.subscriptions.values()) {
            count += subs.size;
        }
        return count;
    }
}

/**
 * Gateway æœåŠ¡
 */
export class GatewayService {
    private config: GatewayConfig;
    private messageQueue!: MessageQueue;
    private rateLimiter!: SlidingWindowLimiter;
    private pendingRequests: Map<string, PendingRequest> = new Map();
    private roomManager: RoomSubscriptionManager = new RoomSubscriptionManager();
    private isRunning: boolean = false;

    constructor(config: GatewayConfig) {
        this.config = config;
    }

    /**
     * å¯åŠ¨ Gateway
     */
    async start(): Promise<void> {
        console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                          â•‘
â•‘       ğŸŒ Gateway Service Starting                       â•‘
â•‘                                                          â•‘
â•‘   Gateway ID: ${this.config.gatewayId.padEnd(39)} â•‘
â•‘   Port: ${this.config.port.toString().padEnd(47)} â•‘
â•‘                                                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        `);

        // åˆå§‹åŒ– DragonflyDB
        console.log('[Gateway] Connecting to DragonflyDB...');
        const client = DragonflyClientManager.initialize({
            host: this.config.dragonflyHost,
            port: this.config.dragonflyPort,
        });

        const health = await DragonflyClientManager.healthCheck();
        if (!health.connected) {
            throw new Error('Failed to connect to DragonflyDB');
        }
        console.log(`[Gateway] Connected to DragonflyDB (latency: ${health.latency}ms)`);

        // åˆå§‹åŒ–é™æµå™¨
        this.rateLimiter = new SlidingWindowLimiter(client, 'drop_coin', 60, 60000);
        console.log('[Gateway] Rate limiter initialized (60 req/min)');

        // åˆå§‹åŒ–æ¶ˆæ¯é˜Ÿåˆ—
        this.messageQueue = new MessageQueue(client, this.config.gatewayId);
        console.log('[Gateway] Message queue initialized');

        // å¼€å§‹æ¶ˆè´¹ç‰©ç†å“åº”
        this.isRunning = true;
        console.log('[Gateway] Starting to consume physics responses...');
        await this.messageQueue.consumePhysicsResponses(
            this.handlePhysicsResponse.bind(this)
        );

        // è®¢é˜…ç‰©ç†å¸§å¹¿æ’­
        console.log('[Gateway] Subscribing to physics frames...');
        await this.messageQueue.subscribePhysicsFrames(
            this.handlePhysicsFrame.bind(this)
        );

        console.log('[Gateway] âœ… Gateway started successfully\n');

        // TODO: å¯åŠ¨ HTTP/WebSocket æœåŠ¡å™¨
        // this.startHttpServer();
    }

    /**
     * å¤„ç†å®¢æˆ·ç«¯è¯·æ±‚ï¼ˆAPI æ¥å£ï¼‰
     */
    async handleClientRequest(
        userId: string,
        roomId: string,
        action: string,
        payload: any
    ): Promise<any> {
        // 1. é™æµæ£€æŸ¥
        const rateLimit = await this.rateLimiter.tryAcquire(userId);
        if (!rateLimit.allowed) {
            throw new Error(`Rate limit exceeded. Reset at ${new Date(rateLimit.resetAt).toISOString()}`);
        }

        // 2. ç”Ÿæˆè¯·æ±‚ ID
        const requestId = uuidv4();

        // 3. åˆ›å»º Promise ç”¨äºç­‰å¾…å“åº”
        const responsePromise = new Promise<any>((resolve, reject) => {
            // è®¾ç½®è¶…æ—¶
            const timeout = setTimeout(() => {
                this.pendingRequests.delete(requestId);
                reject(new Error(`Request timeout after ${this.config.requestTimeout}ms`));
            }, this.config.requestTimeout);

            // ä¿å­˜åˆ°å¾…å¤„ç†åˆ—è¡¨
            this.pendingRequests.set(requestId, {
                requestId,
                resolve,
                reject,
                timeout,
                timestamp: Date.now(),
            });
        });

        // 4. å‘é€è¯·æ±‚åˆ°æ¶ˆæ¯é˜Ÿåˆ—
        const request: PhysicsRequest = {
            requestId,
            roomId,
            userId,
            action,
            payload,
            timestamp: Date.now(),
        };

        await this.messageQueue.publishPhysicsRequest(request);

        console.log(`[Gateway] Request sent: ${action} by ${userId} in ${roomId} (requestId: ${requestId})`);

        // 5. ç­‰å¾…å“åº”
        return responsePromise;
    }

    /**
     * å¤„ç†ç‰©ç†å“åº”
     */
    private async handlePhysicsResponse(response: PhysicsResponse, msgId: string): Promise<void> {
        const { requestId, success, data, error } = response;

        const pending = this.pendingRequests.get(requestId);
        if (!pending) {
            // è¯·æ±‚å¯èƒ½å·²è¶…æ—¶æˆ–å·²å¤„ç†
            return;
        }

        // æ¸…é™¤è¶…æ—¶å®šæ—¶å™¨
        clearTimeout(pending.timeout);
        this.pendingRequests.delete(requestId);

        // è§£æå“åº”
        if (success) {
            pending.resolve(data);
            console.log(`[Gateway] Response received for request ${requestId}: success`);
        } else {
            pending.reject(new Error(error || 'Unknown error'));
            console.log(`[Gateway] Response received for request ${requestId}: error - ${error}`);
        }
    }

    /**
     * å¤„ç†ç‰©ç†å¸§å¹¿æ’­
     */
    private async handlePhysicsFrame(frame: PhysicsFrame): Promise<void> {
        const { roomId, frameId, coins, collected, removed } = frame;

        // è·å–è®¢é˜…è¯¥æˆ¿é—´çš„æ‰€æœ‰è¿æ¥
        const subscribers = this.roomManager.getSubscribers(roomId);

        if (subscribers.size > 0) {
            console.log(`[Gateway] Broadcasting frame ${frameId} to ${subscribers.size} clients in room ${roomId}`);

            // TODO: å®é™…å®ç°ä¸­åº”è¯¥é€šè¿‡ WebSocket å¹¿æ’­
            // for (const connectionId of subscribers) {
            //     const ws = this.connections.get(connectionId);
            //     ws?.send(JSON.stringify({ type: 'physics_frame', frame }));
            // }

            // è§¦å‘äº‹ä»¶ï¼ˆå¯ä»¥è¢«å¤–éƒ¨ç›‘å¬ï¼‰
            this.roomManager.emit('physics_frame', { roomId, frame });
        }
    }

    /**
     * è®¢é˜…æˆ¿é—´æ›´æ–°
     */
    subscribeRoom(roomId: string, connectionId: string): void {
        this.roomManager.subscribe(roomId, connectionId);
        console.log(`[Gateway] Connection ${connectionId} subscribed to room ${roomId}`);
    }

    /**
     * å–æ¶ˆè®¢é˜…æˆ¿é—´
     */
    unsubscribeRoom(roomId: string, connectionId: string): void {
        this.roomManager.unsubscribe(roomId, connectionId);
        console.log(`[Gateway] Connection ${connectionId} unsubscribed from room ${roomId}`);
    }

    /**
     * è¿æ¥æ–­å¼€
     */
    handleDisconnect(connectionId: string): void {
        this.roomManager.unsubscribeAll(connectionId);
        console.log(`[Gateway] Connection ${connectionId} disconnected, cleaned up subscriptions`);
    }

    /**
     * åœæ­¢ Gateway
     */
    async stop(): Promise<void> {
        console.log('[Gateway] Stopping...');

        this.isRunning = false;

        // æ¸…ç†æ‰€æœ‰å¾…å¤„ç†çš„è¯·æ±‚
        for (const [requestId, pending] of this.pendingRequests.entries()) {
            clearTimeout(pending.timeout);
            pending.reject(new Error('Gateway is shutting down'));
        }
        this.pendingRequests.clear();

        // åœæ­¢æ¶ˆæ¯é˜Ÿåˆ—
        if (this.messageQueue) {
            this.messageQueue.stop();
        }

        // æ–­å¼€ DragonflyDB
        await DragonflyClientManager.disconnect();

        console.log('[Gateway] âœ… Gateway stopped');
    }

    /**
     * è·å–çŠ¶æ€
     */
    getStatus() {
        return {
            gatewayId: this.config.gatewayId,
            isRunning: this.isRunning,
            pendingRequests: this.pendingRequests.size,
            subscribedRooms: this.roomManager.getRoomCount(),
            totalSubscribers: this.roomManager.getTotalSubscribers(),
        };
    }
}

// ============ ç¤ºä¾‹ï¼šæ¨¡æ‹Ÿå®¢æˆ·ç«¯è¯·æ±‚ ============

async function exampleUsage() {
    const gateway = new GatewayService({
        gatewayId: 'gateway-1',
        port: 3000,
        dragonflyHost: 'localhost',
        dragonflyPort: 6379,
        requestTimeout: 5000,
    });

    await gateway.start();

    // æ¨¡æ‹Ÿå®¢æˆ·ç«¯è¯·æ±‚
    try {
        const result = await gateway.handleClientRequest(
            'user_123',
            'room_1',
            'drop_coin',
            { x: 0 }
        );
        console.log('[Example] Drop coin result:', result);
    } catch (error: any) {
        console.error('[Example] Request failed:', error.message);
    }
}

// ============ å¯åŠ¨è„šæœ¬ ============

async function main() {
    const config: GatewayConfig = {
        gatewayId: process.env.GATEWAY_ID || `gateway-${process.pid}`,
        port: parseInt(process.env.PORT || '3000', 10),
        dragonflyHost: process.env.DRAGONFLY_HOST || 'localhost',
        dragonflyPort: parseInt(process.env.DRAGONFLY_PORT || '6379', 10),
        requestTimeout: parseInt(process.env.REQUEST_TIMEOUT || '5000', 10),
    };

    const gateway = new GatewayService(config);

    // ä¼˜é›…é€€å‡º
    process.on('SIGINT', async () => {
        console.log('\n[Gateway] Received SIGINT, shutting down...');
        await gateway.stop();
        process.exit(0);
    });

    process.on('SIGTERM', async () => {
        console.log('\n[Gateway] Received SIGTERM, shutting down...');
        await gateway.stop();
        process.exit(0);
    });

    try {
        await gateway.start();

        // å®šæœŸè¾“å‡ºçŠ¶æ€
        setInterval(() => {
            const status = gateway.getStatus();
            console.log(`[Gateway] Status: ${status.pendingRequests} pending, ${status.subscribedRooms} rooms, ${status.totalSubscribers} subscribers`);
        }, 30000);

    } catch (error: any) {
        console.error('[Gateway] Fatal error:', error);
        process.exit(1);
    }
}

// å¦‚æœç›´æ¥è¿è¡Œæ­¤æ–‡ä»¶ï¼Œåˆ™å¯åŠ¨ Gateway
if (require.main === module) {
    main().catch(console.error);
}

export { GatewayService };
